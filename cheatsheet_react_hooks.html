<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Hooks Cheat Sheet - Quick Reference Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        @media print {
            body {
                font-size: 10pt;
            }
            .no-print {
                display: none;
            }
            .page-break {
                page-break-after: always;
            }
            .hook-card {
                break-inside: avoid;
            }
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #61dafb;
            border-bottom: 3px solid #61dafb;
            padding-bottom: 10px;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .download-btn {
            background: #61dafb;
            color: #282c34;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            text-decoration: none;
            display: inline-block;
        }
        
        .download-btn:hover {
            background: #4fa8c5;
        }
        
        .hooks-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .hook-card {
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            background: #fafafa;
        }
        
        .hook-card h3 {
            color: #282c34;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            font-size: 1.2em;
        }
        
        .hook-syntax {
            margin: 10px 0;
        }
        
        .hook-syntax pre {
            margin: 0;
            background: #282c34;
            border-radius: 5px;
            overflow-x: auto;
        }
        
        .hook-syntax code {
            display: block;
            background: #282c34;
            color: #61dafb;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.5;
            white-space: pre;
        }
        
        .hook-description {
            color: #666;
            margin: 10px 0;
            font-size: 0.95em;
        }
        
        .hook-example {
            margin: 10px 0;
        }
        
        .hook-example pre {
            margin: 0;
            background: #f0f0f0;
            border-left: 3px solid #61dafb;
            overflow-x: auto;
        }
        
        .hook-example code {
            display: block;
            background: transparent;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            line-height: 1.5;
            white-space: pre;
            color: #333;
        }
        
        .hook-tips {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
        }
        
        .hook-tips h4 {
            color: #856404;
            margin-bottom: 5px;
        }
        
        .hook-tips ul {
            margin-left: 20px;
            color: #856404;
        }
        
        .category-section {
            margin-bottom: 40px;
        }
        
        .category-title {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .quick-ref-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        .quick-ref-table th,
        .quick-ref-table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }
        
        .quick-ref-table th {
            background: #61dafb;
            color: #282c34;
            font-weight: bold;
        }
        
        .quick-ref-table tr:nth-child(even) {
            background: #f9f9f9;
        }
        
        .best-practices {
            background: #e3f2fd;
            border-radius: 8px;
            padding: 20px;
            margin: 30px 0;
        }
        
        .best-practices h2 {
            color: #1976d2;
            margin-bottom: 15px;
        }
        
        .rules-list {
            list-style: none;
            padding: 0;
        }
        
        .rules-list li {
            padding: 8px 0;
            border-bottom: 1px solid #bbdefb;
        }
        
        .rules-list li:before {
            content: "‚úì ";
            color: #4caf50;
            font-weight: bold;
            margin-right: 10px;
        }
        
        code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>
            ‚öõÔ∏è React Hooks Cheat Sheet
            <button onclick="window.print()" class="download-btn no-print">üì• Print/Save as PDF</button>
        </h1>

        <!-- Quick Reference Table -->
        <section class="category-section">
            <h2 class="category-title">üìä Quick Reference Table</h2>
            <table class="quick-ref-table">
                <thead>
                    <tr>
                        <th>Hook</th>
                        <th>Purpose</th>
                        <th>When to Use</th>
                        <th>Return Value</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>useState</code></td>
                        <td>Manage local state</td>
                        <td>Component needs to track data</td>
                        <td>[state, setState]</td>
                    </tr>
                    <tr>
                        <td><code>useEffect</code></td>
                        <td>Side effects</td>
                        <td>API calls, subscriptions, DOM updates</td>
                        <td>void (cleanup function)</td>
                    </tr>
                    <tr>
                        <td><code>useContext</code></td>
                        <td>Consume context</td>
                        <td>Access global state/theme/auth</td>
                        <td>Context value</td>
                    </tr>
                    <tr>
                        <td><code>useReducer</code></td>
                        <td>Complex state logic</td>
                        <td>Multiple state updates together</td>
                        <td>[state, dispatch]</td>
                    </tr>
                    <tr>
                        <td><code>useCallback</code></td>
                        <td>Memoize functions</td>
                        <td>Prevent unnecessary re-renders</td>
                        <td>Memoized function</td>
                    </tr>
                    <tr>
                        <td><code>useMemo</code></td>
                        <td>Memoize values</td>
                        <td>Expensive calculations</td>
                        <td>Memoized value</td>
                    </tr>
                    <tr>
                        <td><code>useRef</code></td>
                        <td>Mutable ref object</td>
                        <td>DOM access, persist values</td>
                        <td>Ref object</td>
                    </tr>
                    <tr>
                        <td><code>useLayoutEffect</code></td>
                        <td>Sync layout effects</td>
                        <td>DOM measurements</td>
                        <td>void (cleanup function)</td>
                    </tr>
                    <tr>
                        <td><code>useImperativeHandle</code></td>
                        <td>Expose ref methods</td>
                        <td>Parent needs child methods</td>
                        <td>void</td>
                    </tr>
                    <tr>
                        <td><code>useDebugValue</code></td>
                        <td>DevTools label</td>
                        <td>Custom hooks debugging</td>
                        <td>void</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <!-- Core Hooks -->
        <section class="category-section">
            <h2 class="category-title">üéØ Core Hooks</h2>
            <div class="hooks-grid">
                <!-- useState -->
                <div class="hook-card">
                    <h3>useState</h3>
                    <p class="hook-description">Manages local component state</p>
                    <div class="hook-syntax"><pre><code>const [state, setState] = useState(initialValue);</code></pre></div>
                    <div class="hook-example"><pre><code>// Simple counter
const [count, setCount] = useState(0);

// Object state
const [user, setUser] = useState({
  name: '',
  email: ''
});

// Lazy initial state
const [data, setData] = useState(() => {
  return expensiveComputation();
});</code></pre></div>
                    <div class="hook-tips">
                        <h4>üí° Tips:</h4>
                        <ul>
                            <li>State updates are asynchronous</li>
                            <li>Use functional updates for dependent state</li>
                            <li>State updates trigger re-renders</li>
                        </ul>
                    </div>
                </div>

                <!-- useEffect -->
                <div class="hook-card">
                    <h3>useEffect</h3>
                    <p class="hook-description">Handles side effects in components</p>
                    <div class="hook-syntax"><pre><code>useEffect(() => {
  // Effect logic
  return () => {
    // Cleanup (optional)
  };
}, [dependencies]);</code></pre></div>
                    <div class="hook-example"><pre><code>// API call on mount
useEffect(() => {
  fetchData();
}, []); // Empty array = run once

// Watch for changes
useEffect(() => {
  console.log('User changed:', user);
}, [user]);

// Cleanup subscription
useEffect(() => {
  const subscription = subscribe();
  return () => subscription.unsubscribe();
}, []);</code></pre></div>
                    <div class="hook-tips">
                        <h4>üí° Tips:</h4>
                        <ul>
                            <li>Empty deps [] = componentDidMount</li>
                            <li>No deps = runs after every render</li>
                            <li>Return cleanup function to prevent memory leaks</li>
                        </ul>
                    </div>
                </div>

                <!-- useContext -->
                <div class="hook-card">
                    <h3>useContext</h3>
                    <p class="hook-description">Consumes React context values</p>
                    <div class="hook-syntax"><pre><code>const value = useContext(MyContext);</code></pre></div>
                    <div class="hook-example"><pre><code>// Theme context
const ThemeContext = createContext();

// Provider component
function App() {
  return (
    &lt;ThemeContext.Provider value="dark"&gt;
      &lt;Child /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

// Consumer component
function Child() {
  const theme = useContext(ThemeContext);
  return &lt;div className={theme}&gt;...&lt;/div&gt;;
}</code></pre></div>
                    <div class="hook-tips">
                        <h4>üí° Tips:</h4>
                        <ul>
                            <li>Component re-renders when context changes</li>
                            <li>Use multiple contexts for separation</li>
                            <li>Consider performance for frequent updates</li>
                        </ul>
                    </div>
                </div>

                <!-- useReducer -->
                <div class="hook-card">
                    <h3>useReducer</h3>
                    <p class="hook-description">Complex state management with actions</p>
                    <div class="hook-syntax"><pre><code>const [state, dispatch] = useReducer(reducer, initialState);</code></pre></div>
                    <div class="hook-example"><pre><code>const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    case 'reset':
      return initialState;
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(
    reducer, 
    initialState
  );
  
  return (
    &lt;button onClick={() => dispatch({type: 'increment'})}&gt;
      Count: {state.count}
    &lt;/button&gt;
  );
}</code></pre></div>
                    <div class="hook-tips">
                        <h4>üí° Tips:</h4>
                        <ul>
                            <li>Better than useState for complex logic</li>
                            <li>Actions make state updates predictable</li>
                            <li>Great for multiple related state values</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <!-- Performance Hooks -->
        <section class="category-section page-break">
            <h2 class="category-title">‚ö° Performance Hooks</h2>
            <div class="hooks-grid">
                <!-- useCallback -->
                <div class="hook-card">
                    <h3>useCallback</h3>
                    <p class="hook-description">Memoizes callback functions</p>
                    <div class="hook-syntax"><pre><code>const memoizedCallback = useCallback(
  () => { /* function */ },
  [dependencies]
);</code></pre></div>
                    <div class="hook-example"><pre><code>// Prevent child re-renders
const handleClick = useCallback(() => {
  doSomething(a, b);
}, [a, b]);

// Optimized event handler
const SearchBar = ({ onSearch }) => {
  const [query, setQuery] = useState('');
  
  const handleSearch = useCallback(() => {
    onSearch(query);
  }, [query, onSearch]);
  
  return (
    &lt;&gt;
      &lt;input onChange={e => setQuery(e.target.value)} /&gt;
      &lt;button onClick={handleSearch}&gt;Search&lt;/button&gt;
    &lt;/&gt;
  );
};</code></pre></div>
                    <div class="hook-tips">
                        <h4>üí° Tips:</h4>
                        <ul>
                            <li>Use with React.memo for optimization</li>
                            <li>Don't overuse - has overhead</li>
                            <li>Essential for expensive child components</li>
                        </ul>
                    </div>
                </div>

                <!-- useMemo -->
                <div class="hook-card">
                    <h3>useMemo</h3>
                    <p class="hook-description">Memoizes expensive computations</p>
                    <div class="hook-syntax"><pre><code>const memoizedValue = useMemo(
  () => computeExpensiveValue(a, b),
  [a, b]
);</code></pre></div>
                    <div class="hook-example"><pre><code>// Expensive calculation
const expensiveValue = useMemo(() => {
  return items.reduce((sum, item) => {
    return sum + item.value * item.quantity;
  }, 0);
}, [items]);

// Filter/sort optimization
const sortedList = useMemo(() => {
  return [...items].sort((a, b) => b.price - a.price);
}, [items]);

// Complex object creation
const chartData = useMemo(() => ({
  labels: data.map(d => d.label),
  values: data.map(d => d.value),
  colors: generateColors(data.length)
}), [data]);</code></pre></div>
                    <div class="hook-tips">
                        <h4>üí° Tips:</h4>
                        <ul>
                            <li>Only use for expensive operations</li>
                            <li>Profile before optimizing</li>
                            <li>Dependencies must be exhaustive</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <!-- Ref Hooks -->
        <section class="category-section">
            <h2 class="category-title">üìå Ref Hooks</h2>
            <div class="hooks-grid">
                <!-- useRef -->
                <div class="hook-card">
                    <h3>useRef</h3>
                    <p class="hook-description">Creates mutable ref object</p>
                    <div class="hook-syntax"><pre><code>const refContainer = useRef(initialValue);</code></pre></div>
                    <div class="hook-example"><pre><code>// DOM element reference
const inputRef = useRef(null);

useEffect(() => {
  inputRef.current.focus();
}, []);

return &lt;input ref={inputRef} /&gt;;

// Persist value across renders
const renderCount = useRef(0);
renderCount.current++;

// Store previous value
function usePrevious(value) {
  const ref = useRef();
  useEffect(() => {
    ref.current = value;
  });
  return ref.current;
}</code></pre></div>
                    <div class="hook-tips">
                        <h4>üí° Tips:</h4>
                        <ul>
                            <li>.current persists for full lifetime</li>
                            <li>Doesn't trigger re-renders</li>
                            <li>Useful for storing mutable values</li>
                        </ul>
                    </div>
                </div>

                <!-- useImperativeHandle -->
                <div class="hook-card">
                    <h3>useImperativeHandle</h3>
                    <p class="hook-description">Customizes ref exposed to parent</p>
                    <div class="hook-syntax"><pre><code>useImperativeHandle(ref, () => ({
  // exposed methods
}), [deps]);</code></pre></div>
                    <div class="hook-example"><pre><code>// Child component
const FancyInput = forwardRef((props, ref) => {
  const inputRef = useRef();
  
  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus();
    },
    clear: () => {
      inputRef.current.value = '';
    }
  }));
  
  return &lt;input ref={inputRef} /&gt;;
});

// Parent component
const parentRef = useRef();
parentRef.current.focus();
parentRef.current.clear();</code></pre></div>
                    <div class="hook-tips">
                        <h4>üí° Tips:</h4>
                        <ul>
                            <li>Use sparingly - breaks encapsulation</li>
                            <li>Always use with forwardRef</li>
                            <li>Good for form libraries</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <!-- Layout Hooks -->
        <section class="category-section">
            <h2 class="category-title">üìê Layout Hooks</h2>
            <div class="hooks-grid">
                <!-- useLayoutEffect -->
                <div class="hook-card">
                    <h3>useLayoutEffect</h3>
                    <p class="hook-description">Synchronous DOM mutations</p>
                    <div class="hook-syntax"><pre><code>useLayoutEffect(() => {
  // Synchronous effect
}, [deps]);</code></pre></div>
                    <div class="hook-example"><pre><code>// Measure DOM element
function MeasureExample() {
  const [height, setHeight] = useState(0);
  const divRef = useRef();
  
  useLayoutEffect(() => {
    setHeight(divRef.current.getBoundingClientRect().height);
  });
  
  return (
    &lt;div ref={divRef}&gt;
      Height: {height}px
    &lt;/div&gt;
  );
}

// Prevent flicker
useLayoutEffect(() => {
  // DOM updates here won't cause visual flicker
  element.style.opacity = 1;
});</code></pre></div>
                    <div class="hook-tips">
                        <h4>üí° Tips:</h4>
                        <ul>
                            <li>Fires synchronously after DOM mutations</li>
                            <li>Blocks visual updates</li>
                            <li>Use useEffect unless you need sync</li>
                        </ul>
                    </div>
                </div>

                <!-- useDebugValue -->
                <div class="hook-card">
                    <h3>useDebugValue</h3>
                    <p class="hook-description">Display label in React DevTools</p>
                    <div class="hook-syntax"><pre><code>useDebugValue(value, formatFn?);</code></pre></div>
                    <div class="hook-example"><pre><code>// Custom hook with debug info
function useUser(userId) {
  const [user, setUser] = useState(null);
  
  // Display in DevTools
  useDebugValue(user ? `User: ${user.name}` : 'Loading...');
  
  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, [userId]);
  
  return user;
}

// With formatter
useDebugValue(date, date => date.toDateString());</code></pre></div>
                    <div class="hook-tips">
                        <h4>üí° Tips:</h4>
                        <ul>
                            <li>Only visible in React DevTools</li>
                            <li>Use for custom hooks</li>
                            <li>Format function for expensive formatting</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <!-- Custom Hooks Examples -->
        <section class="category-section page-break">
            <h2 class="category-title">üîß Common Custom Hooks Patterns</h2>
            <div class="hooks-grid">
                <!-- useLocalStorage -->
                <div class="hook-card">
                    <h3>useLocalStorage</h3>
                    <div class="hook-example"><pre><code>function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  });
  
  const setValue = value => {
    try {
      setStoredValue(value);
      window.localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error(error);
    }
  };
  
  return [storedValue, setValue];
}</code></pre></div>
                </div>

                <!-- useFetch -->
                <div class="hook-card">
                    <h3>useFetch</h3>
                    <div class="hook-example"><pre><code>function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url);
        const json = await response.json();
        setData(json);
      } catch (error) {
        setError(error);
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, [url]);
  
  return { data, loading, error };
}</code></pre></div>
                </div>

                <!-- useToggle -->
                <div class="hook-card">
                    <h3>useToggle</h3>
                    <div class="hook-example"><pre><code>function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue);
  
  const toggle = useCallback(() => {
    setValue(v => !v);
  }, []);
  
  return [value, toggle];
}

// Usage
const [isOpen, toggleOpen] = useToggle();
const [isDark, toggleTheme] = useToggle(true);</code></pre></div>
                </div>

                <!-- useDebounce -->
                <div class="hook-card">
                    <h3>useDebounce</h3>
                    <div class="hook-example"><pre><code>function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => clearTimeout(handler);
  }, [value, delay]);
  
  return debouncedValue;
}

// Usage
const [searchTerm, setSearchTerm] = useState('');
const debouncedSearch = useDebounce(searchTerm, 500);</code></pre></div>
                </div>
            </div>
        </section>

        <!-- Best Practices -->
        <section class="best-practices">
            <h2>üìö Rules of Hooks & Best Practices</h2>
            <ul class="rules-list">
                <li><strong>Only call hooks at the top level</strong> - Don't call hooks inside loops, conditions, or nested functions</li>
                <li><strong>Only call hooks from React functions</strong> - From React function components or custom hooks</li>
                <li><strong>Name custom hooks with 'use' prefix</strong> - e.g., useAuth, useLocalStorage, useFetch</li>
                <li><strong>Keep dependencies array exhaustive</strong> - Include all values from component scope used inside the effect</li>
                <li><strong>Use ESLint plugin</strong> - Install eslint-plugin-react-hooks for automatic checks</li>
                <li><strong>Don't overuse useMemo/useCallback</strong> - Profile first, optimize only when needed</li>
                <li><strong>Extract complex logic to custom hooks</strong> - Keep components clean and reusable</li>
                <li><strong>Clean up effects</strong> - Return cleanup functions to prevent memory leaks</li>
                <li><strong>Prefer useReducer for complex state</strong> - When multiple state values change together</li>
                <li><strong>Use refs for values that don't need renders</strong> - Previous values, timers, DOM references</li>
            </ul>
        </section>

        <!-- Common Patterns -->
        <section class="category-section">
            <h2 class="category-title">üé® Common Hook Patterns</h2>
            <table class="quick-ref-table">
                <thead>
                    <tr>
                        <th>Pattern</th>
                        <th>Code Example</th>
                        <th>Use Case</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Conditional Effects</td>
                        <td><code>useEffect(() => { if (condition) { /* effect */ } }, [condition])</code></td>
                        <td>Run effect based on condition</td>
                    </tr>
                    <tr>
                        <td>Previous Value</td>
                        <td><code>const prevValue = useRef(); useEffect(() => { prevValue.current = value })</code></td>
                        <td>Track previous prop/state</td>
                    </tr>
                    <tr>
                        <td>Mount Only</td>
                        <td><code>useEffect(() => { /* once */ }, [])</code></td>
                        <td>Run once on mount</td>
                    </tr>
                    <tr>
                        <td>Unmount Cleanup</td>
                        <td><code>useEffect(() => { return () => { /* cleanup */ } }, [])</code></td>
                        <td>Cleanup on unmount</td>
                    </tr>
                    <tr>
                        <td>Force Update</td>
                        <td><code>const [, forceUpdate] = useReducer(x => x + 1, 0)</code></td>
                        <td>Force re-render</td>
                    </tr>
                    <tr>
                        <td>Safe State Update</td>
                        <td><code>setState(prev => prev + 1)</code></td>
                        <td>Update based on previous</td>
                    </tr>
                    <tr>
                        <td>Lazy Initial State</td>
                        <td><code>useState(() => expensiveOperation())</code></td>
                        <td>Expensive initial value</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <footer style="margin-top: 40px; padding-top: 20px; border-top: 2px solid #e0e0e0; text-align: center; color: #666;">
            <p>üìò React Hooks Cheat Sheet v1.0 | Updated for React 18+ | Created with ‚ù§Ô∏è for developers</p>
            <p style="margin-top: 10px;">Print this page or save as PDF for offline reference</p>
        </footer>
    </div>
</body>
</html>
